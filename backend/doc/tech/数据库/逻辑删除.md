# 逻辑删除（软删除）使用指南

## 概述

逻辑删除（Soft Delete）是一种数据删除策略，通过标记字段（`deleted`）来标识记录是否被删除，而不是真正从数据库中物理删除数据。

**优势：**
- ✅ 数据可恢复，防止误删
- ✅ 保留历史记录，便于审计
- ✅ 避免外键级联删除问题
- ✅ 支持数据统计分析

---

## 核心实现

### 1. SoftDeleteMixin - 逻辑删除字段

所有继承 `Base` 的模型都自动包含 `deleted` 字段：

```python
class SoftDeleteMixin(MappedAsDataclass):
    """逻辑删除 Mixin 数据类"""

    deleted: Mapped[int] = mapped_column(
        sa.Integer,
        init=False,
        default=0,
        index=True,
        sort_order=999,
        comment='逻辑删除(0否 1是)',
    )
```

**字段说明：**
- `deleted = 0`：未删除（正常记录）
- `deleted = 1`：已删除（逻辑删除）

---

### 2. 全局自动过滤

项目启用了 **全局逻辑删除过滤器**，所有查询自动添加 `deleted=0` 条件：

```python
# backend/database/db.py
enable_soft_delete_filter(AsyncSession)
```

**工作原理：**
```python
# 你写的代码
result = await db.execute(select(User))

# 实际执行的 SQL（自动添加过滤）
SELECT * FROM user WHERE deleted = 0
```

---

## 使用方法

### 1. 正常查询（自动过滤已删除记录）

```python
from sqlalchemy import select
from backend.app.demo.model import Demo

# 查询所有未删除的记录
async def get_active_demos(db: AsyncSession):
    result = await db.execute(select(Demo))
    demos = result.scalars().all()
    return demos  # 只返回 deleted=0 的记录
```

**生成的 SQL：**
```sql
SELECT * FROM demo WHERE deleted = 0
```

---

### 2. 软删除记录

**方法 A：使用 `soft_delete_method` 函数（推荐）**

```python
from backend.common.soft_delete import soft_delete_method

async def delete_demo(db: AsyncSession, demo_id: int):
    demo = await db.get(Demo, demo_id)
    if not demo:
        raise NotFoundError('记录不存在')

    # 软删除
    soft_delete_method(demo)
    await db.commit()
```

**方法 B：直接设置字段**

```python
async def delete_demo(db: AsyncSession, demo_id: int):
    demo = await db.get(Demo, demo_id)
    demo.deleted = 1
    await db.commit()
```

**方法 C：批量软删除**

```python
from sqlalchemy import update

async def batch_delete_demos(db: AsyncSession, ids: list[int]):
    stmt = update(Demo).where(Demo.id.in_(ids)).values(deleted=1)
    await db.execute(stmt)
    await db.commit()
```

---

### 3. 查询包含已删除的记录

```python
from backend.common.soft_delete import include_deleted

async def get_all_demos_including_deleted(db: AsyncSession):
    # 使用 include_deleted 禁用过滤器
    stmt = include_deleted(select(Demo))
    result = await db.execute(stmt)
    demos = result.scalars().all()
    return demos  # 返回所有记录（包括 deleted=1 的）
```

**生成的 SQL：**
```sql
SELECT * FROM demo  -- 不添加 deleted=0 条件
```

---

### 4. 只查询已删除的记录

```python
async def get_deleted_demos(db: AsyncSession):
    stmt = include_deleted(
        select(Demo).where(Demo.deleted == 1)
    )
    result = await db.execute(stmt)
    deleted_demos = result.scalars().all()
    return deleted_demos
```

**生成的 SQL：**
```sql
SELECT * FROM demo WHERE deleted = 1
```

---

### 5. 恢复已删除的记录

```python
from backend.common.soft_delete import restore_deleted

async def restore_demo(db: AsyncSession, demo_id: int):
    # 先获取已删除的记录
    stmt = include_deleted(select(Demo).where(Demo.id == demo_id))
    result = await db.execute(stmt)
    demo = result.scalar_one_or_none()

    if not demo:
        raise NotFoundError('记录不存在')

    if demo.deleted == 0:
        raise ConflictError('记录未被删除，无需恢复')

    # 恢复记录
    restore_deleted(demo)
    await db.commit()
```

---

### 6. 物理删除（永久删除）

**警告：物理删除后数据无法恢复！**

```python
async def hard_delete_demo(db: AsyncSession, demo_id: int):
    # 获取包括已删除的记录
    stmt = include_deleted(select(Demo).where(Demo.id == demo_id))
    result = await db.execute(stmt)
    demo = result.scalar_one_or_none()

    if demo:
        await db.delete(demo)  # 真正的物理删除
        await db.commit()
```

---

## 实际应用示例

### 示例 1：用户管理系统

```python
from backend.app.demo.model import Demo
from backend.common.soft_delete import soft_delete_method, restore_deleted, include_deleted
from sqlalchemy import select

class DemoService:

    @staticmethod
    async def delete(db: AsyncSession, demo_id: int):
        """软删除用户"""
        demo = await db.get(Demo, demo_id)
        if not demo:
            raise NotFoundError('用户不存在')

        soft_delete_method(demo)
        await db.commit()
        return {'msg': '用户已删除'}

    @staticmethod
    async def get_active_list(db: AsyncSession):
        """获取活跃用户列表（自动过滤已删除）"""
        result = await db.execute(select(Demo))
        return result.scalars().all()

    @staticmethod
    async def get_deleted_list(db: AsyncSession):
        """获取已删除用户列表"""
        stmt = include_deleted(
            select(Demo).where(Demo.deleted == 1)
        )
        result = await db.execute(stmt)
        return result.scalars().all()

    @staticmethod
    async def restore(db: AsyncSession, demo_id: int):
        """恢复已删除用户"""
        stmt = include_deleted(select(Demo).where(Demo.id == demo_id))
        result = await db.execute(stmt)
        demo = result.scalar_one_or_none()

        if not demo:
            raise NotFoundError('用户不存在')

        if demo.deleted == 0:
            raise ConflictError('用户未被删除')

        restore_deleted(demo)
        await db.commit()
        return {'msg': '用户已恢复'}
```

---

### 示例 2：回收站功能

```python
@router.get('/recycle-bin', summary='获取回收站列表')
async def get_recycle_bin(db: CurrentSession):
    """查看回收站中的记录"""
    stmt = include_deleted(
        select(Demo)
        .where(Demo.deleted == 1)
        .order_by(Demo.updated_time.desc())
    )
    result = await db.execute(stmt)
    deleted_items = result.scalars().all()
    return response_base.success(data=deleted_items)


@router.post('/restore/{demo_id}', summary='从回收站恢复')
async def restore_from_recycle_bin(
    db: CurrentSessionTransaction,
    demo_id: int
):
    """恢复已删除的记录"""
    stmt = include_deleted(select(Demo).where(Demo.id == demo_id))
    result = await db.execute(stmt)
    demo = result.scalar_one_or_none()

    if not demo:
        raise NotFoundError('记录不存在')

    restore_deleted(demo)
    return response_base.success(msg='恢复成功')


@router.delete('/permanent/{demo_id}', summary='永久删除')
async def permanent_delete(
    db: CurrentSessionTransaction,
    demo_id: int
):
    """从回收站永久删除（物理删除）"""
    stmt = include_deleted(select(Demo).where(Demo.id == demo_id))
    result = await db.execute(stmt)
    demo = result.scalar_one_or_none()

    if not demo:
        raise NotFoundError('记录不存在')

    await db.delete(demo)
    return response_base.success(msg='永久删除成功')
```

---

## 注意事项

### 1. 唯一性约束问题

逻辑删除可能导致唯一性约束冲突：

**问题：**
```python
# 用户 A 注册 username='alice'
# 软删除用户 A
# 新用户 B 注册 username='alice'  ❌ 唯一约束冲突
```

**解决方案 A：复合唯一索引**

```python
class User(Base):
    username: Mapped[str] = mapped_column(unique=False)  # 移除单字段唯一约束
    deleted: Mapped[int]

    __table_args__ = (
        sa.UniqueConstraint('username', 'deleted', name='uq_username_deleted'),
        # username + deleted 组合唯一，允许同名但 deleted 不同
    )
```

**解决方案 B：软删除时修改用户名**

```python
async def delete_demo(db: AsyncSession, demo_id: int):
    demo = await db.get(Demo, demo_id)
    # 添加删除时间戳，避免冲突
    demo.username = f"{demo.username}_deleted_{int(timezone.now().timestamp())}"
    demo.deleted = 1
    await db.commit()
```

---

### 2. 外键级联问题

逻辑删除不会触发数据库级联删除：

```python
class Order(Base):
    user_id: Mapped[int] = mapped_column(sa.ForeignKey('user.id'))

# 用户软删除后，订单仍然存在
# 需要手动处理关联数据
```

**处理方式：**
```python
async def delete_user_with_orders(db: AsyncSession, user_id: int):
    # 软删除用户
    user = await db.get(User, user_id)
    soft_delete_method(user)

    # 同时软删除关联订单
    stmt = update(Order).where(Order.user_id == user_id).values(deleted=1)
    await db.execute(stmt)

    await db.commit()
```

---

### 3. 分页查询注意事项

逻辑删除会自动过滤，无需手动添加条件：

```python
# ✅ 正确：自动过滤
async def get_demo_list(db: AsyncSession):
    stmt = select(Demo).limit(10).offset(0)
    result = await db.execute(stmt)
    return result.scalars().all()

# ❌ 多余：无需手动添加 deleted=0
async def get_demo_list(db: AsyncSession):
    stmt = select(Demo).where(Demo.deleted == 0).limit(10).offset(0)
    result = await db.execute(stmt)
    return result.scalars().all()
```

---

### 4. 性能优化

为 `deleted` 字段添加索引（已自动配置）：

```python
deleted: Mapped[int] = mapped_column(
    sa.Integer,
    init=False,
    default=0,
    index=True,  # ✅ 已添加索引
    comment='逻辑删除(0否 1是)',
)
```

**查询优化：**
```sql
-- 利用索引快速过滤
SELECT * FROM demo WHERE deleted = 0;

-- 定期清理旧的已删除记录（可选）
DELETE FROM demo WHERE deleted = 1 AND updated_time < NOW() - INTERVAL '90 days';
```

---

## API 接口设计建议

### RESTful API 设计

```python
# 查询列表（只返回未删除）
GET /api/v1/demos

# 查询回收站
GET /api/v1/demos/recycle-bin

# 软删除
DELETE /api/v1/demos/{id}

# 恢复
POST /api/v1/demos/{id}/restore

# 永久删除
DELETE /api/v1/demos/{id}/permanent
```

---

## 工具函数总结

| 函数 | 用途 | 示例 |
|------|------|------|
| `soft_delete_method(instance)` | 软删除单条记录 | `soft_delete_method(user)` |
| `restore_deleted(instance)` | 恢复已删除记录 | `restore_deleted(user)` |
| `include_deleted(query)` | 查询包含已删除的记录 | `include_deleted(select(User))` |

---

## 调试技巧

### 查看实际执行的 SQL

启用 SQL 日志（见下一节"SQL 日志配置"）：

```python
# .env
DATABASE_ECHO=True
```

**输出示例：**
```sql
-- 正常查询
SELECT * FROM demo WHERE deleted = 0

-- 使用 include_deleted
SELECT * FROM demo
```

---

## 总结

✅ **自动过滤**：所有查询自动添加 `deleted=0`
✅ **软删除**：使用 `soft_delete_method()` 标记为删除
✅ **查询全部**：使用 `include_deleted()` 查看包括已删除的记录
✅ **恢复记录**：使用 `restore_deleted()` 恢复数据
✅ **物理删除**：使用 `db.delete()` 永久删除

逻辑删除让数据更安全，但需要注意唯一约束和外键关联问题！
